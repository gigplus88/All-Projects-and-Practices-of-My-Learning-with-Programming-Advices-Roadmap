<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript Type System Demo</title>

    <style></style>
  </head>
  <body>
    <script type="module">
      //Activity1
      /*
        1ï¸âƒ£ Blocking Fetch Result
        ðŸ”¹ The page would freeze

        ðŸ”¹ Buttons would stop working

        ðŸ”¹ Bad user experience


        2ï¸âƒ£ Why Async Is Required
        ðŸ”¹ Network requests take time

        ðŸ”¹ JavaScript must stay responsive

        ðŸ”¹ Async allows waiting without blocking


        3ï¸âƒ£ Better Choice
        âœ” Promises

        Reason:

        Cleaner flow
        Easier error handling
        Easier to extend later with async / await

      */

      //Activity 2

      const paymentPromise = new Promise((resolve, reject) => {
        const isPaid = true; // Ù…Ø­Ø§ÙƒØ§Ø© Ù„Ø¹Ù…Ù„ÙŠØ© Ø¯ÙØ¹

        if (isPaid) {
          resolve("ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­! âœ…");
        } else {
          reject("ÙØ´Ù„Øª Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹! âŒ");
        }
      });

      const onlinePromise = new Promise((resolve, reject) => {
        const isOnline = true; // Ù…Ø­Ø§ÙƒØ§Ø© Ù„Ø¹Ù…Ù„ÙŠØ© Ø¯ÙØ¹

        if (isOnline) {
          resolve("Connected  âœ…");
        } else {
          reject("No connection âŒ");
        }
      });

      //Activity 3

      /*fetchData()
    .then(data => processData(data))
    .then(result => display(result))
    .catch(error => handleError(error))
    .finally(() => hideLoader());*/

      const promise = new Promise((resolve, reject) => {
        const success = true;

        if (success) {
          resolve(10);
        } else {
          reject("Failed");
        }
      });

      promise
        .then((value) => {
          return value * 2;
        })
        .then((result) => {
          console.log(result);
        })
        .catch((error) => console.log("your error is", error))
        .finally(() => {
          console.log("Finished");
        });

      /*
      ðŸ“Œ This demonstrates:

      Success handling
      Error handling
      Cleanup logic
      Promise chaining

    */

      //Full Working example

      /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”‚ Code Overview
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”‚ Purpose        â†’ Demonstrate consuming a Promise in the browser
    â”‚ Layout         â†’ Single HTML file with inline JavaScript
    â”‚ Use Cases      â†’ Learning Promises, async flow, browser behavior
    â”‚ Key Properties â†’ Promise, then(), catch(), finally()
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

      console.log("Page loaded");

      // Create a Promise
      const promise2 = new Promise((resolve, reject) => {
        const success = true; // toggle to false to test error path

        // Simulate async task (e.g. network request)
        setTimeout(() => {
          if (success) {
            resolve(10);
          } else {
            reject("Failed");
          }
        }, 1000);
      });

      // Consume the Promise
      promise2
        .then((value) => {
          console.log("Original value:", value);
          return value * 2; // pass to next step
        })
        .then((result) => {
          console.log("Doubled value:", result);
        })
        .catch((error) => {
          console.error("Error:", error);
        })
        .finally(() => {
          console.log("Finished");
        });

      console.log("JavaScript is non-blocking");

      //Activity 3

      const promise4 = new Promise((resolve, reject) => {
        return new Promise((resolve, rejected) => {
          if (true) {
            resolve(10);
          } else {
            rejected("Finished");
          }
        });
      });

      promise4
        .then((result) => {
          throw new Error("Failure here");
        })
        .then((next) => {
          console.log(next);
        })
        .catch((error) => {
          console.error(error);
        });

      //Activity 4

      const promise5 = new Promise((resolve, reject) => {
        const success = false;

        if (success) {
          resolve("Data loaded");
        } else {
          reject("Network error");
        }
      });

      promise5
        .then((result) => {
          throw new Error("Failure here");
        })
        .then((next) => {
          console.log(next);
        })
        .catch((error) => {
          console.error(error);
        })
        .finally((value) => {
          console.log("Finished");
        });

      /*

      What Happens Without .catch()?
      ðŸ”¹ The Promise rejection is unhandled

      ðŸ”¹ JavaScript reports an unhandled rejection

      ðŸ”¹ The app becomes unstable

      ðŸ“Œ Proper error handling is not optional in async code.

      catch is not 

    */

      /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”‚ Code Overview
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    â”‚ Purpose        â†’ Demonstrate Promise rejection handling in browser
    â”‚ Layout         â†’ Single HTML file with inline JavaScript
    â”‚ Use Cases      â†’ Async error handling, safe cleanup
    â”‚ Key Properties â†’ Promise, then(), catch(), finally()
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

      console.log("Page loaded");

      // Create a Promise
      const promise6 = new Promise((resolve, reject) => {
        const success = false; // toggle to true for success

        // Simulate async task (e.g. API request)
        setTimeout(() => {
          if (success) {
            resolve("Data loaded");
          } else {
            reject("Network error");
          }
        }, 1000);
      });

      // Consume the Promise
      promise6
        .then((result) => {
          console.log("Success:", result);
        })
        .catch((error) => {
          console.error("Error:", error);
        })
        .finally(() => {
          console.log("Finished");
        });

      console.log("JavaScript keeps running while waiting");

      //Activity 5

      const p1 = new Promise((resolve, reject) => {
        const success = false; // toggle to true for success

        // Simulate async task (e.g. API request)
        setTimeout(() => {
          if (success) {
            resolve("Data loaded");
          } else {
            reject("Network error");
          }
        }, 1000);
      });

      const p2 = new Promise((resolve, reject) => {
        const success = false; // toggle to true for success

        // Simulate async task (e.g. API request)
        setTimeout(() => {
          if (success) {
            resolve("Data loaded");
          } else {
            reject("Network error");
          }
        }, 2000);
      });

      const p3 = new Promise((resolve, reject) => {
        const success = false; // toggle to true for success

        // Simulate async task (e.g. API request)
        setTimeout(() => {
          if (success) {
            resolve("Data loaded");
          } else {
            reject("Network error");
          }
        }, 3000);
      });

      /*
     1ï¸âƒ£ Which combinator waits for all results regardless of success?

    Promise.allSettled() â†’ waits for all results
    2ï¸âƒ£ Which combinator fails immediately if one promise fails?

    Promise.all() â†’ fails on first rejection
    3ï¸âƒ£ Which combinator resolves with the first successful promise?

    Promise.any() â†’ first successful resolution
    4ï¸âƒ£ Which combinator finishes when the first promise settles?

    Promise.race() â†’ first settled promise
    */

      //Activity 6

      /*
      
      ðŸ’¡ Activity â€“ Solution
        Consider this scenario:

        A user clicks a button
        Data is fetched from a server
        The UI updates after data arrives
        Answers conceptually:

        1ï¸âƒ£ What does the Promise represent in this flow?

        The Promise represents future server data
        2ï¸âƒ£ When is the value not available yet?

        The value is not available while the Promise is pending
        3ï¸âƒ£ When does the value become usable?

        The value becomes usable inside .then() (or after await)
        4ï¸âƒ£ Which Promise state matches each step?

        States:

        Pending â†’ Fetching data
        Fulfilled â†’ Data received
        Rejected â†’ Request failed

    */






    //Activity 7


    setTimeout(() => console.log("timeout"), 0);

    Promise.resolve().then(() => console.log("promise"));

    queueMicrotask(() => console.log("micro"));



    //ex

      console.log("A");

      setTimeout(() => console.log("B"), 0);

      Promise.resolve().then(() => console.log("C"));

      queueMicrotask(() => console.log("D"));

      console.log("E");

      /*A , E , C , D , B*/




    
      //Activity 7


      let result;

      setTimeout(() => {
        console.log(result);
      }, 0);

      Promise.resolve().then(() => {
        result = 42;
      });




      setTimeout(() => console.log("A"), 0);

      Promise.resolve().then(() => console.log("B"));

      console.log("C");


      /*
        C,B,A
	ðŸ”¹ C â†’ synchronous
	ðŸ”¹ B â†’ microtask
	ðŸ”¹ A â†’ macrotask
      */
     



    </script>
    <script type="module" src="mathUtils.js"></script>
  </body>
</html>
